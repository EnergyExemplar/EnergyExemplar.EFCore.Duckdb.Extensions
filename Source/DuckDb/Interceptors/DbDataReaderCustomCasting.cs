using System.Data.Common;

namespace EnergyExemplar.EntityFrameworkCore.DuckDb.Interceptors
{
    /// <summary>
    /// Implements a custom <see cref="DbDataReader"/> by wrapping an existing reader to provide specialized data conversion logic,
    /// specifically to handle type mismatches that occur when translating complex OData queries through EF Core.
    /// This class follows the Decorator pattern to augment the functionality of a concrete <see cref="DbDataReader"/> instance at runtime.
    /// </summary>
    /// <remarks>
    /// <para>
    /// <strong>Problem Context: OData, EF Core, and Subquery Type Mismatches</strong>
    /// When using OData with EF Core, complex queries involving multiple `$expand` operations and projections are translated into SQL.
    /// EF Core often generates subqueries to handle these, particularly for calculated fields or checking for the existence of related entities (e.g., using `.Any()`).
    /// A common SQL pattern generated by EF Core for boolean values is `CASE WHEN EXISTS(...) THEN 1 ELSE 0 END`.
    /// This results in a column of integer type (`1` or `0`) in the database's result set.
    /// </para>
    /// <para>
    /// However, the EF Core model expects a `bool`. When the default <see cref="DbDataReader"/> tries to read this integer value using `GetBoolean()`,
    /// it can fail with an `InvalidCastException` if the underlying ADO.NET provider doesn't support this specific conversion implicitly.
    /// This class is designed to bridge that gap.
    /// </para>
    /// <para>
    /// <strong>Example Scenario: OData `$expand` with a Calculated Boolean</strong>
    /// Consider an OData query that retrieves categories and expands their products, including a calculated boolean field `IsHighValue` on each product.
    /// <code>
    /// GET /odata/Categories?$expand=Products($select=ProductName,IsHighValue)
    /// </code>
    /// Let's say `IsHighValue` is true if a product's price is over 1000. The EF Core LINQ query might look like this:
    /// <code>
    /// context.Categories
    ///   .Include(c => c.Products) // Mapped to a projection with IsHighValue
    ///   .Select(c => new CategoryDto {
    ///     // ...
    ///     Products = c.Products.Select(p => new ProductDto {
    ///       ProductName = p.Name,
    ///       IsHighValue = p.Price > 1000 // This becomes the subquery
    ///     })
    ///   })
    /// </code>
    /// EF Core might translate this into a SQL query containing a sub-select for products, where `IsHighValue` is generated as:
    /// <code>
    /// (CASE WHEN "p"."Price" > 1000 THEN 1 ELSE 0 END) AS "IsHighValue"
    /// </code>
    /// When materializing the `ProductDto` objects, EF Core will call `GetBoolean()` on the `IsHighValue` column.
    /// This custom reader intercepts that call and correctly converts the `1` or `0` into `true` or `false`.
    /// </para>
    /// <para>
    /// <strong>Solution:</strong>
    /// By wrapping the original data reader, this class overrides the <see cref="GetBoolean"/> method to provide more robust casting logic.
    /// It handles conversions from integers, longs, and even strings, ensuring that boolean properties in the EF Core model are populated correctly,
    /// thus preventing runtime errors and making the OData query translation more resilient.
    /// All other data reader operations are delegated to the inner reader, preserving the original behavior for all other data types.
    /// </para>
    /// </remarks>
    public class DbDataReaderCustomCasting : DbDataReader
    {
        private readonly DbDataReader _inner;

        public DbDataReaderCustomCasting(DbDataReader inner)
        {
            _inner = inner;
        }

        protected override void Dispose(bool disposing)
        {
            if (disposing)
            {
                _inner.Dispose();
            }
            base.Dispose(disposing);
        }

        public override bool GetBoolean(int ordinal)
        {
            var value = _inner.GetValue(ordinal);
            if (value is bool b) return b;
            if (value is int i) return i != 0;
            if (value is long l) return l != 0;
            if (value is string s)
            {
                if (bool.TryParse(s, out var result))
                {
                    return result;
                }
                if (int.TryParse(s, out var intResult))
                {
                    return intResult != 0;
                }
            }
            // Add other conversions if necessary
            return Convert.ToBoolean(value);
        }

        // Delegate all other members to the inner reader
        public override object this[int ordinal] => _inner[ordinal];
        public override object this[string name] => _inner[name];
        public override int Depth => _inner.Depth;
        public override int FieldCount => _inner.FieldCount;
        public override bool HasRows => _inner.HasRows;
        public override bool IsClosed => _inner.IsClosed;
        public override int RecordsAffected => _inner.RecordsAffected;
        public override bool NextResult() => _inner.NextResult();
        public override bool Read() => _inner.Read();
        public override int GetValues(object[] values) => _inner.GetValues(values);
        public override string GetName(int ordinal) => _inner.GetName(ordinal);
        public override int GetOrdinal(string name) => _inner.GetOrdinal(name);
        public override string GetDataTypeName(int ordinal) => _inner.GetDataTypeName(ordinal);
        public override Type GetFieldType(int ordinal) => _inner.GetFieldType(ordinal);
        public override object GetValue(int ordinal) => _inner.GetValue(ordinal);
        public override byte GetByte(int ordinal) => _inner.GetByte(ordinal);
        public override long GetBytes(int ordinal, long dataOffset, byte[] buffer, int bufferOffset, int length) => _inner.GetBytes(ordinal, dataOffset, buffer, bufferOffset, length);
        public override char GetChar(int ordinal) => _inner.GetChar(ordinal);
        public override long GetChars(int ordinal, long dataOffset, char[] buffer, int bufferOffset, int length) => _inner.GetChars(ordinal, dataOffset, buffer, bufferOffset, length);
        public override Guid GetGuid(int ordinal) => _inner.GetGuid(ordinal);
        public override short GetInt16(int ordinal) => _inner.GetInt16(ordinal);
        public override int GetInt32(int ordinal) => _inner.GetInt32(ordinal);
        public override long GetInt64(int ordinal)
        {
            var value = _inner.GetValue(ordinal);

            switch (value)
            {
                case long l:
                    return l;
                case int i:
                    return i;
                case short s:
                    return s;
                case byte b:
                    return b;
                case decimal dec:
                    return Convert.ToInt64(dec);
                case double d:
                    return Convert.ToInt64(d);
                case float f:
                    return Convert.ToInt64(f);
                case string s:
                    if (long.TryParse(s, out var parsedLong))
                    {
                        return parsedLong;
                    }
                    if (decimal.TryParse(s, System.Globalization.NumberStyles.Any, System.Globalization.CultureInfo.InvariantCulture, out var parsedDecimal))
                    {
                        return Convert.ToInt64(parsedDecimal);
                    }
                    break;
            }

            // Fallback: attempt generic conversion which covers nullable types & enums
            // Convert.ToInt64(DBNull.Value) returns 0.
            return Convert.ToInt64(value);
        }
        public override float GetFloat(int ordinal) => _inner.GetFloat(ordinal);
        public override double GetDouble(int ordinal) => _inner.GetDouble(ordinal);
        public override string GetString(int ordinal) => _inner.GetString(ordinal);
        public override decimal GetDecimal(int ordinal) => _inner.GetDecimal(ordinal);
        public override DateTime GetDateTime(int ordinal) => _inner.GetDateTime(ordinal);
        public override bool IsDBNull(int ordinal) => _inner.IsDBNull(ordinal);
        public override System.Collections.IEnumerator GetEnumerator() => _inner.GetEnumerator();
    }
}