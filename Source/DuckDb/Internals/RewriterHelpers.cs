using System.Text;

namespace EnergyExemplar.Extensions.DuckDb.Internals
{
    /// <summary>
    /// Provides utility methods for SQL rewriting operations, specifically for converting SQLite syntax
    /// to DuckDB-compatible syntax. Contains helper functions used by the SQL rewrite rules to perform
    /// complex string transformations and pattern matching.
    /// </summary>
    public static class RewriterHelpers
    {
        /// <summary>
        /// Converts "FROM json_each('[1,2]') AS g" into "FROM UNNEST([1,2]) AS g(value)".
        /// Assumes pattern generated by EF Core for Contains().
        /// </summary>
        public static string ConvertJsonEach(string sql)
        {
            const string func = "json_each('";
            int idx = 0;
            var sb = new StringBuilder(sql.Length);
            while (true)
            {
                int nextIdx = sql.IndexOf(func, idx, StringComparison.OrdinalIgnoreCase);
                if (nextIdx == -1)
                {
                    sb.Append(sql, idx, sql.Length - idx);
                    break;
                }

                // copy preceding segment
                sb.Append(sql, idx, nextIdx - idx);
                int startJson = nextIdx + func.Length;
                int endQuote = sql.IndexOf("')", startJson, StringComparison.Ordinal);
                if (endQuote == -1) // malformed; copy rest and bail
                {
                    sb.Append(sql, nextIdx, sql.Length - nextIdx);
                    break;
                }

                string jsonArray = sql.Substring(startJson, endQuote - startJson);

                // convert JSON string array to DuckDB list constant format
                string duckList = jsonArray.Replace("\"", "'");

                int afterJson = endQuote + 2; // position after ")"

                // check for optional alias " AS <alias>"
                int asIdx = sql.IndexOf(" AS ", afterJson, StringComparison.OrdinalIgnoreCase);
                bool hasAlias = asIdx != -1;
                if (hasAlias)
                {
                    // ensure AS occurs immediately after without nested clauses before comma/where etc.
                    // only treat as alias if no other character except whitespace between afterJson and asIdx
                    string between = sql.Substring(afterJson, asIdx - afterJson);
                    hasAlias = string.IsNullOrWhiteSpace(between);
                }

                if (hasAlias)
                {
                    int aliasStart = asIdx + 4;
                    int aliasEnd = aliasStart;
                    while (aliasEnd < sql.Length)
                    {
                        char ch = sql[aliasEnd];
                        if (char.IsLetterOrDigit(ch) || ch == '_' || ch == '"')
                        {
                            aliasEnd++;
                            continue;
                        }
                        break;
                    }
                    string alias = sql.Substring(aliasStart, aliasEnd - aliasStart);
                    string asKeyword = sql.Substring(asIdx + 1, 2); // preserves original case (AS/as)
                    sb.Append($"UNNEST({duckList}) {asKeyword} {alias}(value)");
                    idx = aliasEnd;
                }
                else
                {
                    sb.Append($"UNNEST({duckList})");
                    idx = afterJson;
                }
            }
            return sb.ToString();
        }
    }
}